#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>

namespace glos::clcr
{

constexpr std::string NOISE_AMOUNT_DIAL_ID = "NOISE_AMOUNT";
constexpr std::string NOISE_AMOUNT_DIAL_TEXT = "Noise Amount";

/**
 * @brief Gaussian white noise generator using the Box-Muller transform.
 * 
 */
class BoxMullerNoise : public juce::dsp::ProcessorBase
{
public:

    /**
     * @brief Construct a new Box Muller Noise object
     * 
     */
    BoxMullerNoise() = default;

    /**
     * @brief Construct a new Box Muller Noise object
     * 
     * @param numChannels Number of channels to generate noise for
     * @param sampleRate Host sample rate
     */
    BoxMullerNoise(int numChannels, int sampleRate);

    /**
     * @brief Set the noise amount parameter.
     * 
     * @param noiseAmount Noise amount parameter
     */
    void setNoiseAmount(std::atomic<float>* noiseAmount) noexcept;

    /**
     * @brief Get the noise amount parameter
     * 
     * @return std::atomic<float>*
     */
    std::atomic<float>* getNoiseAmount() const noexcept;

    /**
     * @brief Sets the number of channels to generate noise for and the sample rate.
     * 
     * @param spec Process specification containing audio host info.
     */
    void prepare(const juce::dsp::ProcessSpec& spec) override;
    
    /**
     * @brief Process the audio context by dithering in the incoming audio sample buffer
     * with noise.
     * 
     * @param context Context information containing input and output audio blocks.
     */
    void process(const juce::dsp::ProcessContextReplacing<float>& context) override;

    /**
     * @brief Resets the noise generator state.  This clears sets the precomputed sample to 0.0
     * and clears the noise buffer.
     * 
     */
    void reset() override;

private:
    /**
     * @brief Compute a gaussian noise sample using the Box-Muller transform.  This implementation
     * uses the Marsaglia polar method instead of the standard trigonometric version of the Box-Muller
     * transform, which is more efficient and avoids the need for executing trigonometric functions in the audio
     * processing loop.
     * 
     * @return float 
     */
    float nextSample() noexcept;

    /**
     * @brief Compute a fixed number of gaussian noise samples.
     * 
     * @param n Number of samples to generate
     * @return std::AudioBuffer<float>
     */
    juce::AudioBuffer<float> nextNSamples(int n) noexcept;

    bool m_usePrecomputedSample = false; /**< Boolean flag used for determining if a precomupted sample can be used */
    float m_precomputedSample = 0.0f; /**< Value that stores one of the two value generated by the Box-Muller method  */

    std::atomic<float>* m_noiseAmount = nullptr; /**< Percentage of signal made up by generated noise */

    juce::Random m_random = juce::Random(); /**< Uniformly distributed random number generator */
    juce::AudioBuffer<float> m_samples = juce::AudioBuffer<float>(1, 44100); /**< AudioBuffer to store multiple samples if needed */
};

}