#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>

#include "processors/SynchronizedProcessor.h"
#include "ProcessorParam.h"

namespace glos::clcr
{

/**
 * @class BoxMullerNoise
 * @brief Gaussian white noise generator using the Box-Muller transform.
 * This effect is a SynchronizedProcessor based class that will take an incoming
 * audio signal in a juce::ProcessorChain and dither the signal with noise.
 * 
 */
class BoxMullerNoise : public SynchronizedProcessor
{
public:

    /**
     * @brief Construct a new Box Muller Noise object
     *
     */
    BoxMullerNoise()
        : m_noiseAmount(0.0f)
    {
    }

    /**
     * @brief Set the noise amount by percentage of noise to add to the signal.
     * 
     * @param noiseAmount Amount of noise to add to the signal [0.0, 1.0]
     */
    void setNoiseAmount(float noiseAmount) noexcept;

    /**
     * @brief Get the noise amount
     * 
     * @return Noise amount value
     */
    float getNoiseAmount() const noexcept;

    /**
     * @brief Sets the sample rate and number of channels to generate noise for.
     * 
     * @param spec Process specification containing audio host info.
     */
    void prepare(const juce::dsp::ProcessSpec& spec) override;
    
    /**
     * @brief Process the audio context by adding noise to the incoming 
     * audio sample buffer.
     * 
     * @param context Context information containing input and output audio blocks.
     */
    void process(const juce::dsp::ProcessContextReplacing<float>& context) override;

    /**
     * @brief Resets the noise generator state.  This clears sets the precomputed sample to 0.0
     * and clears the noise buffer.
     * 
     */
    void reset() override;

    /**
     * @brief Register the processor parameters with the given AudioProcessorValueTreeState.
     * 
     * @param apvts AudioProcessorValueTreeState to register parameters with.
     */
    void registerParameters(juce::AudioProcessorValueTreeState& apvts) override;

    static constexpr char NOISE_AMOUNT_DIAL_ID[] = "NOISE_AMOUNT"; /**< Parameter ID for noise amount dial */
    static constexpr char NOISE_AMOUNT_DIAL_TEXT[] = "Noise Amount"; /**< Parameter text for noise amount dial */

private:
    /**
     * @brief Compute a gaussian noise sample using the Box-Muller transform.  This implementation
     * uses the Marsaglia polar method instead of the standard trigonometric version of the Box-Muller
     * transform, which is more efficient and avoids the need for executing trigonometric functions in the audio
     * processing loop.
     * 
     * @return float 
     */
    float nextSample() noexcept;

    /**
     * @brief Compute a fixed number of gaussian noise samples.
     * 
     * @param n Number of samples to generate
     * @return std::AudioBuffer<float>
     */
    juce::AudioBuffer<float> nextNSamples(int n) noexcept;

    bool m_usePrecomputedSample = false; /**< Boolean flag used for determining if a precomupted sample can be used */
    float m_precomputedSample = 0.0f; /**< Value that stores one of the two value generated by the Box-Muller method  */

    ProcessorParam<
        NOISE_AMOUNT_DIAL_ID,
        NOISE_AMOUNT_DIAL_TEXT,
        float
    > m_noiseAmount; /**< Percentage of signal made up by generated noise */

    juce::Random m_random = juce::Random(); /**< Uniformly distributed random number generator */
    juce::AudioBuffer<float> m_samples = juce::AudioBuffer<float>(1, 44100); /**< AudioBuffer to store multiple samples if needed */
};

}