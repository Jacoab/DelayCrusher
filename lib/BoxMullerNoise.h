#pragma once

#include <juce_core/juce_core.h>

namespace glos::clcr
{

/**
 * @brief Gaussian white noise generator using the Box-Muller transform.
 * 
 */
class BoxMullerNoise
{
public:

    /**
     * @brief Construct a new Box Muller Noise object
     * 
     */
    BoxMullerNoise() :
        m_random(),
        m_usePrecomputedSample(false),
        m_precomputedSample(0.0f)
    {
    }

    /**
     * @brief Compute a gaussian noise sample using the Box-Muller transform.  This implementation
     * uses the Marsaglia polar method instead of the standard trigonometric version of the Box-Muller
     * transform, which is more efficient and avoids the need for executing trigonometric functions in the audio
     * processing loop.
     * 
     * @return float 
     */
    float nextSample() noexcept
    {
        // Since the Box-Muller transform generates two independent samples, check to see if
        // we already have a pre-computed sample to return.
        if (m_usePrecomputedSample) 
        {
            m_usePrecomputedSample = false;
            return m_precomputedSample;
        }

        float u, v, s;
        do 
        {
            u = 2.0f * m_random.nextFloat() - 1.0f;
            v = 2.0f * m_random.nextFloat() - 1.0f;
            s = u * u + v * v;
        } while (s >= 1.0f || s == 0.0f);

        auto multiplier = std::sqrt(-2.0f * std::log(s) / s);
        m_precomputedSample = v * multiplier;
        m_usePrecomputedSample = true;
        return u * multiplier;
    }

    /**
     * @brief Compute a fixed number of gaussian noise samples.
     * 
     * @tparam N Number of samples to generate
     * @return std::array<float, N> 
     */
    template <std::size_t N>
    std::array<float, N> nextNSamples() noexcept
    {
        std::array<float, N> samples;
        for (auto i = 0; i < N; ++i)
        {
            samples[i] = nextSample();
        }
        return samples;
    }

private:
    juce::Random m_random; /**< Uniformly distributed random number generator */
    bool m_usePrecomputedSample; /**< Boolean flag used for determining if a precomupted sample can be used */
    float m_precomputedSample; /**< Value that stores one of the two value generated by the Box-Muller method  */
};

}