#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>

namespace glos::clcr
{

/**
 * @brief Gaussian white noise generator using the Box-Muller transform.
 * 
 */
class BoxMullerNoise
{
public:

    /**
     * @brief Construct a new Box Muller Noise object
     * 
     */
    BoxMullerNoise() :
        m_random(),
        m_usePrecomputedSample(false),
        m_precomputedSample(0.0f),
        m_samples(1, 44100)
    {
    }

    /**
     * @brief Construct a new Box Muller Noise object
     * 
     */
    BoxMullerNoise(int numChannels, int sampleRate) :
        m_random(),
        m_usePrecomputedSample(false),
        m_precomputedSample(0.0f),
        m_samples(numChannels, sampleRate)
    {
    }

    /**
     * @brief Compute a gaussian noise sample using the Box-Muller transform.  This implementation
     * uses the Marsaglia polar method instead of the standard trigonometric version of the Box-Muller
     * transform, which is more efficient and avoids the need for executing trigonometric functions in the audio
     * processing loop.
     * 
     * @return float 
     */
    float nextSample() noexcept
    {
        // Since the Box-Muller transform generates two independent samples, check to see if
        // we already have a pre-computed sample to return.
        if (m_usePrecomputedSample) 
        {
            m_usePrecomputedSample = false;
            return m_precomputedSample;
        }

        float u, v, s;
        do 
        {
            u = 2.0f * m_random.nextFloat() - 1.0f;
            v = 2.0f * m_random.nextFloat() - 1.0f;
            s = u * u + v * v;
        } while (s >= 1.0f || s == 0.0f);

        auto multiplier = std::sqrt(-2.0f * std::log(s) / s);
        m_precomputedSample = v * multiplier;
        m_usePrecomputedSample = true;
        return u * multiplier;
    }

    /**
     * @brief Compute a fixed number of gaussian noise samples.
     * 
     * @param n Number of samples to generate
     * @return std::AudioBuffer<float>&
     */
    juce::AudioBuffer<float>& nextNSamples(int n) noexcept
    {
        jassert (n > 0 && n <= m_samples.getNumSamples());

        m_samples.clear();
        for (auto channel = 0; channel < m_samples.getNumChannels(); ++channel)
        {
            auto* samples = m_samples.getWritePointer(channel);
            for (auto i = 0; i < n; ++i)
            {
                samples[i] = nextSample();
            }
        }
        return m_samples;
    }

private:
    juce::Random m_random; /**< Uniformly distributed random number generator */
    bool m_usePrecomputedSample; /**< Boolean flag used for determining if a precomupted sample can be used */
    float m_precomputedSample; /**< Value that stores one of the two value generated by the Box-Muller method  */
    juce::AudioBuffer<float> m_samples; /**< AudioBuffer to store multiple samples if needed */
};

}